jeportie@minishell $> cd test_dir
0
jeportie@minishell $> echo a*
a1 a2 a3 a4
0
jeportie@minishell $> echo *1
a1 b1
0
jeportie@minishell $> export a=test
0
jeportie@minishell $> echo $a
test
0
jeportie@minishell $> cd ..
0
jeportie@minishell $> cd ..
0
jeportie@minishell $> cat s*/*x*/ms*c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_concat_path.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeportie <jeportie@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 13:57:10 by jeportie          #+#    #+#             */
/*   Updated: 2024/11/26 16:39:15 by jeportie         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/exec.h"

static void	ms_check_alloc(void *ptr, t_gc *gcl)
{
	if (!ptr)
	{
		ft_dprintf(STDERR_FILENO, "error: minishell: memory allocation error");
		gc_cleanup(gcl);
		exit(EXIT_FAILURE);
	}
}

char	*ms_concat_path(const char *path, const char *command, t_gc *gcl)
{
	char	*cmd_path;
	char	*tmp;

	tmp = gc_strjoin((char *)path, "/", gcl);
	ms_check_alloc(tmp, gcl);
	cmd_path = gc_strjoin(tmp, (char *)command, gcl);
	ms_check_alloc(cmd_path, gcl);
	return (cmd_path);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_ast.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeportie <jeportie@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 09:32:42 by jeportie          #+#    #+#             */
/*   Updated: 2024/12/10 15:12:48 by jeportie         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/exec.h"

static int	redirect_switch(t_ast_node *to_child, t_ast_node *node,
		t_exec_context *context, t_proc_manager *manager)
{
	if (context->redirected == false)
	{
		if (ms_handle_redirections(node, context, manager,
				context->shell->gcl) != 0)
			return (-1);
	}
	return (ms_execute_ast(to_child, context, manager));
}

int	ms_execute_ast(t_ast_node *node, t_exec_context *context,
	t_proc_manager *manager)
{
	if (!node)
		return (ms_handle_error("Error: Null AST node.\n", -1,
				context->shell->gcl));
	if (node->type == NODE_COMMAND)
		return (ms_execute_command(&node->data.command, context, manager,
				context->shell->gcl));
	else if (node->type == NODE_PIPE)
		return (ms_execute_pipeline(&node->data.pipe, context, manager));
	else if (node->type == NODE_AND || node->type == NODE_OR)
		return (ms_execute_logical(&node->data.logic, context, node->type,
				manager));
	else if (node->type == NODE_SUBSHELL)
		return (ms_execute_subshell(&node->data.subshell, context, manager));
	else if (node->type == NODE_REDIRECT_IN || node->type == NODE_REDIRECT_OUT
		|| node->type == NODE_REDIRECT_APPEND)
		return (redirect_switch(node->data.redirect.child, node, context,
				manager));
	else if (node->type == NODE_REDIRECT_HEREDOC)
		return (redirect_switch(node->data.heredoc.child, node, context,
				manager));
	else
		return (ms_handle_error("Unsupported node type", -1,
				context->shell->gcl));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_command.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeportie <jeportie@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/14 16:07:30 by jeportie          #+#    #+#             */
/*   Updated: 2024/12/04 10:19:47 by jeportie         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/exec.h"
#include "../../include/expand.h"
#include "../../include/builtins.h"

static void	st_set_underscore_value(t_cmd_node *cmd_node,
		t_exec_context *context, t_gc *gcl)
{
	int	i;

	i = 0;
	ms_manage_arg_expand(cmd_node, context, gcl);
	while (cmd_node->argv[i] != NULL)
		i++;
	ms_set_env_value(context->shell, "_", cmd_node->argv[i - 1]);
}

int	ms_execute_command(t_cmd_node *cmd_node, t_exec_context *context,
	t_proc_manager *manager, t_gc *gcl)
{
	char *(cmd) = cmd_node->argv[0];
	st_set_underscore_value(cmd_node, context, gcl);
	if (ft_strncmp(cmd, "echo", 5) == 0)
		return (ms_echo(cmd_node, context->stdout_fd));
	else if (ft_strncmp(cmd, "cd", 3) == 0)
		return (ms_cd(cmd_node, context->shell));
	else if (ft_strncmp(cmd, "pwd", 4) == 0)
		return (ms_pwd(context->stdout_fd));
	else if (ft_strncmp(cmd, "export", 7) == 0)
		return (ms_export(cmd_node, context));
	else if (ft_strncmp(cmd, "unset", 6) == 0)
		return (ms_unset(cmd_node, context));
	else if (ft_strncmp(cmd, "env", 4) == 0)
	{
		if (cmd_node->argc > 1 && !ft_strncmp(cmd_node->argv[1], "-i", 3))
			return (ms_execute_external(cmd_node, context, manager, gcl));
		return (ms_env(cmd_node, context));
	}
	else if (ft_strncmp(cmd, "exit", 5) == 0)
		return (ms_exit(cmd_node, context));
	else if (is_equal(cmd))
		return (ms_value_assign(context->shell, cmd_node, gcl));
	else
		return (ms_execute_external(cmd_node, context, manager, gcl));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ms_execute_external.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gmarquis <gmarquis@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 12:43:01 by jeportie          #+#    #+#             */
/*   Updated: 2024/12/10 22:17:11 by jeportie         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/exec.h"
#include "../../include/process.h"
#include <unistd.h>

static void	ms_child_process(t_cmd_node *cmd_node, t_exec_context *context,
			char *cmd_path, t_gc *gcl)
{
	char	**envp;
	t_gc	*child_gcl;

	ms_init_child_cmd_signal();
	child_gcl = gc_init();
	if (!init_io(context->stdin_fd, context->stdout_fd, context->stderr_fd))
		exit(ms_handle_error("minishell: redirection error: dup2\n",
				EXIT_FAILURE, gcl));
	envp = ms_get_envp(context->shell->env_data->env, child_gcl);
	if (!envp)
		exit(ms_handle_error("memory allocation error\n", EXIT_FAILURE, gcl));
	gc_nest_register(envp, child_gcl);
	execve(cmd_path, cmd_node->argv, envp);
	ft_dprintf(STDERR_FILENO, "minishell: execve error");
	gc_cleanup(child_gcl);
	exit(EXIT_FAILURE);
}

static void	ms_parent_process(pid_t pid, t_exec_context *context)
{
	int	status;

	if (context->stdin_fd != STDIN_FILENO)
		safe_close(context->stdin_fd);
	if (context->stdout_fd != STDOUT_FILENO)
		safe_close(context->stdout_fd);
	if (context->stderr_fd != STDERR_FILENO)
		safe_close(context->stderr_fd);
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		context->shell->error_code = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		context->shell->error_code = 128 + WTERMSIG(status);
	else
		context->shell->error_code = -1;
}

int	ms_execute_external(t_cmd_node *cmd_node, t_exec_context *context,
		t_proc_manager *manager, t_gc *gcl)
{
	t_fork_params (fork_params);
	char *(cmd_path) = ms_parse_cmd_path(cmd_node->argv[0], context->shell);
	if (cmd_path == NULL)
	{
		if (ft_strchr(cmd_node->argv[0], '/'))
			ft_dprintf(STDERR_FILENO, "bash: %s: No such file or directory\n",
				cm