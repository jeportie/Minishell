TEST signaux de base:
Ctrl+C et Ctrl+\ sont bon mais j'ai trouver un segfault si Ctrl+D apres avoir fait des test sur env et pwd
(je n'arrive pas a le reproduire)
    ptit'coque> pwd
    /home/gmarquis/Code/Minishell
    ptit'coque> ^C
    ptit'coque> ^C
    ptit'coque> ^C
    ptit'coque> ^C
    ptit'coque> 
    [1]    14377 segmentation fault (core dumped)  ./Minishell



TEST signaux commande bloquante:
Comportement normal sauf probleme avec les signaux.
    ptit'coque> cat
                                            //  ici j'ai taper entrer pour voir le comportement (c'est bon)

    d
    d
    ^C                                      //  jusqu'ici tout est bon, CTRL+C
    ptit'coque> ptit'coque>                 //  double prompt a regler dans les signaux (surment dans l'enfant)
    Minishell: Error: No Input provided.    //  taper entrer a creer une erreur surment a cause du double prompt



TEST signaux heredocs:
    Test avec Ctrl+D:
    Le Ctrl+D devrait afficher un message d'erreur mais faire le heredoc normalement
        Notre minishell:
            ptit'coque> cat << EOF
            > ici
            > la
            > minishell: warning: heredoc process exited with status 1
            Minishell: Error: heredoc failed.
        Le posix:
            bash-5.1$ cat << EOF
            > ici
            > la
            > 
            bash: avertissement : « here-document » à la ligne 60 délimité par la fin du fichier (au lieu de « EOF »)
            ici
            la
    Test avec Ctrl+C:
    Le Ctrl+C ne doit pas afficher de message d'erreur et ne pas faire le heredoc
        Notre minishell:
            ptit'coque> cat << EOF
            > ici
            > la
            > ^C
            ptit'coque> minishell: heredoc process terminated by signal 2
            Minishell: Error: heredoc failed.
        Le posix:
            bash-5.1$ cat << EOF
            > ici
            > la
            > ^C
    Test avec Ctrl+\:
    Le Ctrl+\ doit etre igniorer
        Notre minishell:
            ptit'coque> cat << EOF
            > ici
            > la
            > ^\minishell: heredoc process terminated by signal 3   //  ici j'ai taper CTRL+\ ca ne devrait rien faire
            Minishell: Error: heredoc failed.
        Le posix:
            bash-5.1$ cat << EOF
            > ici
            > la
            > ^C                                                    //  ici j'ai taper CTRL+\ ca ne fonctionne pas c'est normal (donc j'ai taper Ctrl+C)
J'ai aussi trouver un segfault a la suite des test:
    ptit'coque> cat << EOF
    > ici
    > la
    > EOF
    ici
    la
    ptit'coque> cat << EOF
    > ici
    > la
    > minishell: warning: heredoc process exited with status 1
    Minishell: Error: heredoc failed.
    ptit'coque> cat << EOF
    > ici
    > la
    > ^C
    ptit'coque> minishell: heredoc process terminated by signal 2
    Minishell: Error: heredoc failed.
    ptit'coque> cat << EOF
    > ici
    > la
    > ^\minishell: heredoc process terminated by signal 3
    Minishell: Error: heredoc failed.
    ptit'coque> clear
    [1]    22808 segmentation fault (core dumped)  ./Minishell

	ptit'coque> cat << OEF
	> in
	> out
	> OEF
	in
	out
	ptit'coque> cat << OEF
	> in
	> minishell: warning: heredoc process exited with status 1
	Minishell: Error: heredoc failed.
	ptit'coque> cat << OEF
	> in
	> ^C
	ptit'coque> minishell: heredoc process terminated by signal 2
	Minishell: Error: heredoc failed.
	ptit'coque> cat
	minishell: command not found: cat
	ptit'coque> cat
	[2]    1321 segmentation fault (core dumped)  ./Minishell



TEST pipe
gross leaks



TEST $?:
Ne fonctionne pas affiche une ligne vide.
    ptit'coque> ls
    assets	 lib	 Makefile	 Minishell  src     test_src
    include  main.c  make_interface  obj	    test.c  ycm_extra_conf.py
    ptit'coque> echo $?
                                        //  code erreur non gerer a voir dans les expand



TEST $_
La variable _ est invalide, elle contient toujours "/home/gmarquis/Code/Minishell/./Minishell_".
Cette variable contient la dernierre commande en pass absolut ou bien la dernierre option de la commande precedente.
EX:
apres la commande env
    bash-5.1$ env | grep $_
    _=/usr/bin/env
apres la commande ls -la
    bash-5.1$ env | grep $_
    _=-la



TEST path absolut:
Nickel



TEST path relatif:
Nickel



TEST sans path:
Nickel



TEST permission des fichiers:
Probleme si les droit d'ecriture ne sont pas valide les commandes ne devrait pas s'executer
Ex:
si je touch outfile puis chmod 000 outfile
    Notre minishell:
        ptit'coque> env | grep PWD | cat -e > outfile && cat outfile | wc -l > outfile
        Minishell: Error: open failed.
        PWD=/home/gmarquis/Code/Minishell$
        OLDPWD=/home/gmarquis/Code$
        Minishell: Error: open failed.
        cat: outfile: Permission non accordée
        0
    Le posix:
        bash-5.1$ env | grep PWD | cat -e > outfile && cat outfile | wc -l > outfile
        bash: outfile: Permission non accordée



TEST code erreur Ctrl+c:
Nickel



TEST Commande incorrect:
Erreur le code est 0 mais devrait etre 127
    ptit'coque> lsp
    minishell: command not found: lsp
    ptit'coque> 
    gmarquis@u-home-fix~/Code/Minishell> echo $?    
    0




TEST Execution de dossier:
Code erreur faut et mauvais message d'erreur
    Notre minishell:
        ptit'coque> ./src/
        minishell: execve errorfree(): double free detected in tcache 2
        ptit'coque> 
        gmarquis@u-home-fix~/Code/Minishell> echo $?    
        0
    le posix:
        bash-5.1$ ./src/
        bash: ./src/ : est un dossier
        bash-5.1$ echo $?
        126



TEST expand et simple quote:
    Avec '$USER'
    Erreur l'expand ce fait
        Notre minishell:
            ptit'coque> echo '$USER'
            gmarquis
        Le posix:
            bash-5.1$ echo '$USER'
            $USER
    Avec '"$USER"'
    Erreur l'expand ce fait
        Notre minishell:
            ptit'coque> echo '"$USER"'
            gmarquis
        Le posix:
            bash-5.1$ echo '"$USER"'
            "$USER"



TEST expand et double quote:
Nickel



TEST pipe:
Ca ma l'air nickel mais il ya telement de possibiliter que je referait des tests quand tout sera debuguer



TEST operateur logique:
Ca ma l'air nickel mais il ya telement de possibiliter que je referait des tests quand tout sera debuguer



TEST cd:
Nickel, bien qu'on est une gestion bonne mais differente si on tente un cd .. dans des dossier supprimer.
EX:
Si je suis dans Minishell/dir0/dir1/dir2 et que je rm -rf ../../../dir0 et que je cd .. j'aurais un message d'erreur correct.
Mais le comportement differre du --posix si je fait plusieurs cd ..
Notre minishell va simuler le faite de remonter dans les dossier en affichant des message d'erreur (dans cette exemple 3 cd .. a faire pour regagner Minishell/).
Le posix lui va laisser l'utilisateur faire deux cd .. puis a la troisieme tentative executera un cd sans option (ce qui reverra a /home/$USER)
Je trouve notre gestion meilleurs mais si tu veut implementer la meme que posix je modifirait.



TEST echo:
Nickel



TEST env:
Nickel



TEST pwd:
Nickel



TEST export:
Le += ne concatenne pas!
il change la variable choisie et supprime toutes les autres variable export avant lui.
(corriger le 18 mauvaise gestion du garbage colector dans add_cat)

Apres un export sans option l'env reste classer, verifier avec env
(corriger le 19 modification de l'env original et non d'une copie lors du trie ar ordre ascii)

export affiche var="" meme si l'export a ete faite avec sellement var
(corriger le 19 le utils->flag n'etais pas reinitialiser dans la boucle)



TEST unset:
Casse si unset est utiliser avec plusieurs options (peut etre different a 42 a tester sur place).
EX:
    ptit'coque> env
    ...
    a=ok
    b=
    c=(null)
    ptit'coque> unset a b c
    Error: Pointer not managed by GC.
(corriger le 18 mauvaise gestion du garbage colector dans export)



TEST exit:
Comportement valide sauf pour exit et une option valide ou il y a segfault.
    ptit'coque> exit 123
    exit
    [1]    22300 segmentation fault (core dumped)  ./Minishell
    gmarquis@u-home-fix~/Code/Minishell> echo $?    
    139
(corriger le 18 la variable envoyer a ft_atol etait free par gc_cleanup)

